import { z } from "zod";
import { TopicSelector } from "../topic.ts";
import { generateId } from "../updates.ts";
import { HttpError, ValidationError } from "./_errors.ts";
import { authorize, keyResolver } from "./authorization.ts";
import type { HandlerFn } from "./router.ts";
import { checkContentType, extractFormData, parseFormBody } from "./utils.ts";
import { MercureTokenPayload } from "../jws.ts";

/**
 * Handle the publication of a message.
 *
 * The publisher sends updates by issuing `POST` HTTPS requests on the hub URL.
 * When it receives an update, the hub dispatches it to subscribers using the
 * established server-sent events connections.
 *
 * The hub **MAY** also dispatch this update using other protocols such as
 * {@link https://www.w3.org/TR/websub/|WebSub} or
 * {@link https://www.w3.org/TR/activitypub/|ActivityPub}.
 *
 * An application **CAN** send events directly to subscribers without using an
 * external hub server, if it is able to do so.
 * In this case, it **MAY NOT** implement the endpoint to publish updates.
 *
 * The request **MUST** be encoded using the
 * {@link https://html.spec.whatwg.org/|`application/x-www-form-urlencoded`
 * format} and contain the following name-value tuples:
 *
 *  - `topic`: The identifiers of the updated topic. It is **RECOMMENDED** to
 *    use an IRI as identifier. If this name is present several times, the first
 *    occurrence is considered to be the canonical IRI of the topic, and other
 *    ones are considered to be alternate IRIs. The hub **MUST** dispatch this
 *    update to subscribers that are subscribed to both canonical or alternate
 *    IRIs.
 *  - `data` (optional): the content of the new version of this topic.
 *  - `private` (optional): if this name is set, the update **MUST NOT** be
 *    dispatched to subscribers not authorized to receive it.
 *    See {@link https://mercure.rocks/spec#authorization|authorization}.
 *    It is recommended to set the value to `on`, but it **CAN** contain any
 *    value including an empty string.
 *  - `id` (optional): the topic's revision identifier: it will be used as the
 *    SSE's `id` property. The provided ID **MUST NOT** start with the `#`
 *    character. The provided ID **SHOULD** be a valid IRI. If omitted, the hub
 *    **MUST** generate a valid {@link https://tools.ietf.org/html/rfc3987|IRI
 *    (RFC3987)}. A {@link https://tools.ietf.org/html/rfc4122|UUID (RFC4122)}
 *    or a {@link https://www.w3.org/TR/did-core/|DID} **MAY** be used.
 *    Alternatively the hub **MAY** generate a relative URI composed of a
 *    fragment (starting with `#`). This is convenient to return an offset or a
 *    sequence that is unique for this hub. Even if provided, the hub **MAY**
 *    ignore the ID provided by the client and generate its own ID.
 *  - `type` (optional): the SSE's `event` property (a specific event type).
 *  - `retry` (optional): the SSE's `retry` property (the reconnection time).
 *
 * In the event of success, the HTTP response's body **MUST** be the id
 * associated to this update generated by the hub and a success HTTP status code
 * **MUST** be returned. The publisher **MUST** be authorized to publish
 * updates. See {@link https://mercure.rocks/spec#authorization|authorization}.
 *
 * @param request
 * @example ```http
 *          POST /.well-known/mercure HTTP/1.1
 *          Host: example.com
 *          Content-Type: application/x-www-form-urlencoded
 *          Authorization: Bearer [snip]
 *
 *          topic=https://example.com/foo&data=the%20content
 *          ```
 *          ```http
 *          HTTP/1.1 200 OK
 *          Content-type: text/plain
 *
 *          urn:uuid:e1ee88e2-532a-4d6f-ba70-f0f8bd584022
 *          ```
 *
 * @see https://mercure.rocks/spec#publication Mercure Spec: Publication
 */
export const handlePublication = async function handlePublication(
  { request, url, config, hub },
) {
  // Authorize the request and extract the claims from the JWT payload
  const claims = await authorize(
    request,
    config,
    keyResolver("publisher"),
  );

  // Verify the token claims, and extract all topic selectors the publisher is
  // authorized to publish updates for.
  const authorizedTopics = checkClaims(claims, url);

  // Verify the request's content type matches the specification.
  checkContentType(request, "application/x-www-form-urlencoded");

  const rawBody = await parseFormBody(request);
  const { data: payload, error } = publicationSchema.safeParse(
    extractFormData(rawBody),
  );

  if (error) {
    throw new ValidationError(error);
  }

  const {
    id,
    data,
    retry,
    topic: topics,
    type,
  } = payload;

  // Check if the publisher is authorized to publish the topics
  for (const topic of topics) {
    const authorized = authorizedTopics.some((selector) => selector.test(topic));

    if (!authorized) {
      throw new HttpError(
        403,
        `Forbidden: Not authorized to publish updates for topic "${topic}"`,
      );
    }
  }

  const [canonicalTopic, ...alternateTopics] = topics;

  hub.dispatchEvent(
    new MessageEvent("update", {
      data: {
        id,
        canonicalTopic,
        alternateTopics,
        data,
        retry,
        type,
      },
    }),
  );

  return new Response(id, { status: 200 });
} satisfies HandlerFn;

const publicationSchema = z.object({
  topic: z
    .union([
      z.string(),
      z.array(z.string()).nonempty("The topics are mandatory."),
    ], {
      required_error: "The topics are mandatory.",
      description:
        "The identifiers of the updated topic. It is RECOMMENDED to use an IRI as identifier. If this name " +
        "is present several times, the first occurrence is considered to be the canonical IRI of the topic, " +
        "and other ones are considered to be alternate IRIs. The hub MUST dispatch this update to " +
        "subscribers that are subscribed to both canonical or alternate IRIs.",
    })
    .transform((value) => Array.isArray(value) ? value : [value] satisfies [string, ...string[]]),
  data: z
    .string({
      description: "The content of the new version of this topic.",
    })
    .optional(),
  private: z
    .string({
      description:
        "If this name is set, the update MUST NOT be dispatched to subscribers not authorized " +
        "to receive it. See authorization. It is recommended to set the value to on but it CAN contain " +
        "any value including an empty string.",
    })
    .optional()
    .transform((value) =>
      value && [
        "true",
        "1",
        "yes",
        "on",
      ].includes(value)
    )
    .pipe(z.boolean().default(true)),
  id: z
    .string({
      description:
        "The topic's revision identifier: it will be used as the SSE's id property. The provided ID " +
        "MUST NOT start with the # character. The provided ID SHOULD be a valid IRI. If omitted, the hub " +
        "MUST generate a valid IRI (RFC3987). An UUID (RFC4122) or a DID MAY be used. Alternatively the " +
        "hub MAY generate a relative URI composed of a fragment (starting with #). This is convenient to " +
        "return an offset or a sequence that is unique for this hub. Even if provided, the hub MAY " +
        "ignore the ID provided by the client and generate its own ID.",
    })
    .optional()
    .refine(
      (value) => typeof value === "undefined" || !value.startsWith("#"),
      { message: "The ID must not start with the '#' character" },
    )
    .default(() => generateId()),
  type: z
    .string({
      description: "The SSE's event property (a specific event type).",
    })
    .optional(),
  retry: z
    .number({
      description: "The SSE's retry property (the reconnection time).",
    })
    .positive()
    .optional(),
});

function checkClaims(claims: MercureTokenPayload | undefined, baseUrl: URL) {
  if (!claims) {
    throw new HttpError(403, "Forbidden");
  }

  if (!claims.mercure) {
    throw new HttpError(
      403,
      `Forbidden: Missing "mercure" claim`,
    );
  }

  try {
    const properties = JSON.parse(claims.mercure.toString());
    const { publish: topics } = z
      .object({
        publish: z
          .array(z.string(), {
            message: "Invalid publish claim",
          })
          .nonempty({
            message: "The publish claim must contain at least one topic",
          })
          .transform((topics) => topics.map((topic) => new TopicSelector(topic, baseUrl))),
      })
      .parse(properties);

    return topics;
  } catch (cause) {
    throw new HttpError(
      403,
      `Forbidden: Invalid "mercure" claim: ${cause}`,
      {},
      cause,
    );
  }
}
